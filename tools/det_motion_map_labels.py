import numpy as np
import pickle
import os
import json
import shutil
import cv2
from pyquaternion import Quaternion
import matplotlib.pyplot as plt
import visvalingamwyatt as vw
import sys
sys.path.append('/root/data1/ltp/codes/ad/VAD/')
###### generate the texts of ego car
infos = pickle.load(open('/root/data1/ltp/codes/ad/VAD/data/nuscenes-ltp/val_trajs_valor_v2.pickle', 'rb'))
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/nuscene_infos/val_cmd.pickle', 'rb') as file:
    infos_cmd = pickle.load(file)
captions_nuscene_train = {}
names_nuscene_train=[]
for name in infos:
    sentences=[]
    cmd = infos_cmd[name]
    if cmd[0]==1:
        command = '{turn right}.'
    elif cmd[1]==1:
        command = '{turn left}.'
    elif cmd[2]==1:
        command = '{go straight}.'
    data= infos[name][1:,:].astype(float) - infos[name][:6,:].astype(float)
    data = (data*10).astype(int)
    result_str = "{" + ", ".join([f"[{x},{y}]" for x, y in data]) + "}"
    sentence = 'the ego car will ' + command + ' ' + 'the future trajectory for the next 6 timestamps will be ' + result_str + '.'
    sentences.append(sentence)
    captions_nuscene_train[name]=sentences
    names_nuscene_train.append(name)
with open('./datasets/nuscene/captions_finetune_val.json', 'w') as f:
    json.dump(captions_nuscene_train, f)
with open('./datasets/nuscene/val_ids.json', 'w') as f:
    json.dump(names_nuscene_train, f)
print('finish')
###### stage1
###### find the empty map and add with the predicted map generated by VAD,
###### corresponded codes are in datasets/nuscenes_vad_dataset.py about line 1154
# map_root = '/root/data1/ltp/codes/ad/VAD/data/nuscene_map_infos/aaai25/train/'
# map_root2='/root/data1/ltp/codes/ad/VAD/data/nuscene_map_infos/train/'
# map_names = os.listdir(map_root)
# bad_token_names = []
# num=0
# map_pts_labels={}
# for name in map_names:
#     map_path = map_root + name
#     map_info = pickle.load(open(map_path, 'rb'))
#     map_labels = map_info['map_gt_labels_3d'].data.cpu().numpy()
#     if len(map_labels) < 1:
#         bad_token_names.append(name[:-4])
#         continue
#     map_pts = map_info['map_gt_bboxes_3d'].data.fixed_num_sampled_points.cpu().numpy()
#     num+=1
#     print(num)
#     results=[]
#     results.append(map_labels)
#     results.append(map_pts)
#     map_pts_labels[name[:-4]]=results
# with open('/root/data1/ltp/codes/ad/VAD/data/nuscene_map_infos/gpvl_maps_info.pkl', 'wb') as f:
#     pickle.dump(map_pts_labels, f)
# with open('/root/data1/ltp/codes/ad/VAD/data/nuscene_map_infos/gpvl_maps_bad_names.pkl', 'wb') as f:
#     pickle.dump(bad_token_names, f)
###### stage2
###### generate texts of det motion map
captions_ego = json.load(open('./datasets/nuscene/captions_nuscene_train.json'))
map_infos = pickle.load(open('./nuscene_map_infos/gpvl_maps_info_train.pkl', 'rb'))
ann_train_root = '/root/data1/ltp/codes/ad/VAD/data/nuscenes/vad_nuscenes_infos_temporal_train.pkl'
ann_infos= pickle.load(open(ann_train_root, 'rb'))['infos']
captions_pretrain = {}
captions_pretrain_map={}
captions_pretrain_motion={}
captions_pretrain_det={}
pretrain_ids=[]
numx=0
for ann_info in ann_infos:
    token_name= ann_info['token']
    ### maps
    map_classes_prompts=['the lane belongs to divider', 'the lane belongs to pedestrain crossing', 'the lane belongs to boundary']
    description_maps=''
    if token_name in map_infos:
        ### maps
        map_classes = map_infos[token_name][0]
        map_pts = map_infos[token_name][1]
        map_pts2 = map_pts.astype(np.float64)
        map_pts2 = np.round(map_pts2, 1)
        map_pts2 = map_pts2.astype(int)
        maps_tmp = ""
        for j in range(len(map_pts2)):
            ####
            label=map_classes[j]
            if label==1 or label==2:
                map_class_prompt = map_classes_prompts[label]
                ####
                pts2 = map_pts2[j]
                simplifier = vw.Simplifier(pts2)
                pts_simple=simplifier.simplify(number=3)
                map_pts_prompt = "{" + ", ".join([f"[{x}, {y}]" for x, y in pts_simple]) + "}"
                maps_tmp = maps_tmp + map_pts_prompt
        description_maps = 'the locations of lanes are' + ' ' + maps_tmp
        ### boxes
        gt_boxes = ann_info['gt_boxes'][:, :2]
        gt_boxes2 = np.round(gt_boxes, 1)
        gt_boxes2 = gt_boxes2*10
        gt_boxes2 = gt_boxes2.astype(int)
        result_str = "{" + ", ".join([f"[{x}, {y}]" for x, y in gt_boxes2]) + "}"
        description_boxes = 'locations of other agents on the road are ' + result_str + '.'
        ### trajectory
        gt_agent_fut_trajs = ann_info['gt_agent_fut_trajs']
        agent_nums = gt_agent_fut_trajs.shape[0]
        gt_agent_fut_trajs = np.reshape(gt_agent_fut_trajs, (agent_nums, 6, 2))
        gt_agent_fut_trajs2 = np.cumsum(gt_agent_fut_trajs, axis=1)
        gt_boxes_trajs = gt_boxes[:, :2].reshape(agent_nums, 1, 2)
        gt_boxes_trajs2 = np.repeat(gt_boxes_trajs, 6, axis=1)
        gt_agent_fut_trajs3 = gt_agent_fut_trajs2 + gt_boxes_trajs2
        gt_agent_fut_trajs3 = np.round(gt_agent_fut_trajs3, 1)
        gt_agent_fut_trajs3=gt_agent_fut_trajs3*10
        gt_agent_fut_trajs3=gt_agent_fut_trajs3.astype(int)
        trajs_tmp = ""
        #### filter the trajs v2
        threshold = 1
        displacements = np.linalg.norm(np.diff(gt_agent_fut_trajs3, axis=1), axis=2)
        static_mask = np.all(displacements < threshold, axis=1)
        gt_agent_fut_trajs_filter = gt_agent_fut_trajs3[~static_mask]
        agent_nums=len(gt_agent_fut_trajs_filter)
        #### filter the trajs
        for i in range(agent_nums):
            fut_trajs = gt_agent_fut_trajs_filter[i]
            fut_trajs = fut_trajs[[1,3,5],:]
            result_str2 = "{" + ", ".join([f"[{x}, {y}]" for x, y in fut_trajs]) + "}"
            trajs_tmp = trajs_tmp + result_str2 + ' '
        description_trajs = 'the future trajectories of other agents in next 3 seconds are ' + trajs_tmp + '.'
        description_global = description_boxes + ' ' + description_trajs + ' ' + description_maps
        description_global_list=[]
        description_boxes_list=[]
        description_trajs_list=[]
        description_maps_list=[]
        description_global_list.append(description_global)
        description_boxes_list.append(description_boxes)
        description_trajs_list.append(description_trajs)
        description_maps_list.append(description_maps)
        captions_pretrain[token_name] = description_global_list
        captions_pretrain_det[token_name] = description_boxes_list
        captions_pretrain_motion[token_name] = description_trajs_list
        captions_pretrain_map[token_name] = description_maps_list
        pretrain_ids.append(token_name)
        numx+=1
        print(numx)
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/GPVL/datasets/nuscene/captions_pretrain_det_motion_map_10x.json', 'w') as f:
    json.dump(captions_pretrain, f)
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/GPVL/datasets/nuscene/captions_pretrain_det_10x.json', 'w') as f:
    json.dump(captions_pretrain_det, f)
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/GPVL/datasets/nuscene/captions_pretrain_motion_10x.json', 'w') as f:
    json.dump(captions_pretrain_motion, f)
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/GPVL/datasets/nuscene/captions_pretrain_map_10x.json', 'w') as f:
    json.dump(captions_pretrain_map, f)
with open('/root/data1/ltp/codes/vision-language/VALOR-mine/GPVL/datasets/nuscene/pretrain_ids.json', 'w') as f:
    json.dump(pretrain_ids, f)